/*!
 * -------------------------------------------
 * Copyright (c) 2019, Horizon Robotics, Inc.
 * All rights reserved.
 * \File     msg_manager.h
 * \Author   Yingmin Li
 * \Mail     yingmin.li@horizon.ai
 * \Version  1.0.0.0
 * \Date     2019-04-22
 * \Brief    implement of msg_manager.h
 * \DO NOT MODIFY THIS COMMENT, \
 * \WHICH IS AUTO GENERATED BY EDITOR
 * -------------------------------------------
 */

#ifndef XPROTO_SRC_INCLUDE_XPROTO_MSG_MANAGER_H_
#define XPROTO_SRC_INCLUDE_XPROTO_MSG_MANAGER_H_
#include <algorithm>
#include <iostream>
#include <map>
#include <memory>
#include <mutex>
#include <string>
#include <vector>

#include "hobotlog/hobotlog.hpp"
#include "xproto/message/flowmsg.h"
#include "xproto/message/msg_registry.h"
#include "xproto/plugin/xplugin.h"
#include "xproto/plugin/xpluginasync.h"
#include "xproto/session/xsession_inner.h"
#include "xproto/threadpool.h"
#include "xproto/utils/singleton.h"

namespace xproto {
class XMsgQueue : public xproto::CSingleton<XMsgQueue> {
 public:
  XMsgQueue() {
    msg_handle_.CreatThread(1);
    auto max_plugin_msg_str = getenv("max_plugin_msg");
    if (max_plugin_msg_str) {
      max_plugin_msg_ = atoi(max_plugin_msg_str);
    }
    auto msg_timeout_monitor_str = getenv("msg_timeout_monitor");
    if (msg_timeout_monitor_str) {
      msg_timeout_monitor_ = atoi(msg_timeout_monitor_str);
    }
  }
  ~XMsgQueue() = default;

 public:
  void RegisterPlugin(const XPluginPtr &plugin, const std::string &msg_type,
                      const int32_t msg_source) {
    std::lock_guard<std::mutex> lck(mutex_);
    int Log_level = GetLogLevel();
    if (Log_level == 7) {  // HOBOT_LOG_NULL
      SetLogLevel(HOBOT_LOG_WARN);
    }
    auto type_handle = XPluginMsgRegistry::Instance().Get(msg_type);
    if (type_handle == XPLUGIN_INVALID_MSG_TYPE) {
      LOGW << "try to register invalid msg type:" << msg_type << ", for plugin "
           << plugin->desc();
      return;
    }
    auto async_plugin = std::dynamic_pointer_cast<XPluginAsync>(plugin);
    if (async_plugin) {
      int monitor_time = async_plugin->GetMsgMonitorTime();
      if (monitor_time <= 0) {
        // plugin本身没有设置超时时间时，则设置为默认的超时时间
        async_plugin->SetMsgMonitorTime(msg_timeout_monitor_);
      }
    }
    table_[type_handle].push_back(plugin);
    if (0 == msg_source) {
      XSessionInner::Instance().RegisterMsg(msg_type);
    }
  }
  void UnRegisterPlugin(const XPluginPtr &plugin, const std::string &msg_type) {
    std::lock_guard<std::mutex> lck(mutex_);
    auto type_handle = XPluginMsgRegistry::Instance().Get(msg_type);
    if (type_handle == XPLUGIN_INVALID_MSG_TYPE ||
        table_.find(type_handle) == table_.end()) {
      LOGW << "try to unregister invalid msg type:" << msg_type
           << ", for plugin " << plugin->desc();
      return;
    }
    auto iter = std::find(table_[type_handle].begin(),
                          table_[type_handle].end(), plugin);
    if (iter != table_[type_handle].end()) {
      LOGW << "to erase plugin: " << plugin->desc();
      table_[type_handle].erase(iter);
    }
    XSessionInner::Instance().UnRegisterMsg(msg_type);
  }

  void PushMsg(XProtoMessagePtr msg, const int32_t msg_dst) {
    auto type_handle = XPluginMsgRegistry::Instance().Get(msg->type());
    if (type_handle == XPLUGIN_INVALID_MSG_TYPE) {
      LOGW << "push no consumer message，type:" << msg->type();
      return;
    }
    std::unique_lock<std::mutex> lck(mutex_);  // support add and del plugins
    auto &plugins = table_[type_handle];
    while (true) {
      auto msg_queue_normal = true;
      for (auto &plugin : plugins) {
        auto async_plugin = std::dynamic_pointer_cast<XPluginAsync>(plugin);
        if (async_plugin) {
          // 流量控制只对XPluginAsync有用
          auto msg_count = async_plugin->GetPluginMsgCount();
          auto plugin_msg_limit = async_plugin->GetPluginMsgLimit();
          auto max_plugin_msg_count =
              plugin_msg_limit <= 0 ? max_plugin_msg_ : plugin_msg_limit;
          if (msg_count >= max_plugin_msg_count) {
            msg_queue_normal = false;
            break;
          }
        }
      }
      if (false == msg_queue_normal) {
        lck.unlock();
        LOGI << "PushMsg type: " << msg->type()
             << ", try to wait 500us until plugin msg-queue is free.";
        std::this_thread::sleep_for(std::chrono::microseconds(500));
        lck.lock();
      } else {
        lck.unlock();
        break;
      }
    }
    msg_handle_.PostTask(std::bind(&XMsgQueue::Dispatch, this, msg, msg_dst));
  }

  int TryPushMsg(XProtoMessagePtr msg, const int32_t msg_dst) {
    auto type_handle = XPluginMsgRegistry::Instance().Get(msg->type());
    if (type_handle == XPLUGIN_INVALID_MSG_TYPE) {
      LOGW << "push no consumer message，type:" << msg->type();
      return -1;
    }
    auto msg_queue_normal = true;
    {
      std::lock_guard<std::mutex> lck(mutex_);
      auto &plugins = table_[type_handle];
      for (auto &plugin : plugins) {
        auto async_plugin = std::dynamic_pointer_cast<XPluginAsync>(plugin);
        if (async_plugin) {
          auto msg_count = async_plugin->GetPluginMsgCount();
          auto plugin_msg_limit = async_plugin->GetPluginMsgLimit();
          auto max_plugin_msg_count =
              plugin_msg_limit <= 0 ? max_plugin_msg_ : plugin_msg_limit;
          if (msg_count >= max_plugin_msg_count) {
            msg_queue_normal = false;
            break;
          }
        }
      }
    }
    if (false == msg_queue_normal) {
      return -1;
    }
    msg_handle_.PostTask(std::bind(&XMsgQueue::Dispatch, this, msg, msg_dst));
    return 0;
  }

 private:
  void Dispatch(XProtoMessagePtr msg, const int32_t msg_dst) {
    std::lock_guard<std::mutex> lck(mutex_);
    auto type_handle = XPluginMsgRegistry::Instance().Get(msg->type());
    if (type_handle == XPLUGIN_INVALID_MSG_TYPE) {
      LOGW << "push no consumer message，type:" << msg->type();
      return;
    }
    auto &plugins = table_[type_handle];
    for (auto &plugin : plugins) {
      plugin->OnMsg(msg);
    }
    if (0 == msg_dst) {
      XSessionInner::Instance().Dispatch(msg);
    }
  }

 private:
  std::map<XPluginMsgTypeHandle, std::vector<XPluginPtr>> table_;
  xproto::CThreadPool msg_handle_;

  std::mutex mutex_;
  int max_plugin_msg_ = 30;
  int msg_timeout_monitor_ = 1000;  // ms
};

}  // namespace xproto

#endif  // XPROTO_SRC_INCLUDE_XPROTO_MSG_MANAGER_H_
