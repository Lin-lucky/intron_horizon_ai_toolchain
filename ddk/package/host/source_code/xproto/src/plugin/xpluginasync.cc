/*!
 * -------------------------------------------
 * Copyright (c) 2019, Horizon Robotics, Inc.
 * All rights reserved.
 * \File     plugin.cpp
 * \Author   Yingmin Li
 * \Mail     yingmin.li@horizon.ai
 * \Contributor Songshan Gong
 * \Mail     songshan.gong@horizon.ai
 * \Version  1.0.0.0
 * \Date     2019-07-28
 * \Brief    XPluginAsync implementation
 * \DO NOT MODIFY THIS COMMENT, \
 * \WHICH IS AUTO GENERATED BY EDITOR
 * -------------------------------------------
 */
#include "xproto/plugin/xpluginasync.h"

#include "hobotlog/hobotlog.hpp"
#include "xproto/msg_manager.h"
#include "xproto/plugin/xplugin.h"
#include "xproto/threadpool.h"

namespace xproto {

int XPluginAsync::Init() {
  LOGI << "XPluginAsync::Init";
  return 0;
}

void XPluginAsync::RegisterMsg(const std::string &type,
                               XProtoMessageFunc callback,
                               int32_t msg_source) {
  std::lock_guard<std::mutex> lock(msg_map_mutex_);
  HOBOT_CHECK(msg_map_.count(type) == 0)
      << "type:" << type << " already registered.";
  XPlugin::RegisterMsg(type, msg_source);
  msg_map_[type] = callback;
}

void XPluginAsync::UnRegisterMsg(const std::string &type) {
  std::lock_guard<std::mutex> lock(msg_map_mutex_);
  auto iter = msg_map_.find(type);
  if (iter == msg_map_.end()) {
    return;
  }
  XPlugin::UnRegisterMsg(type);
  msg_map_.erase(iter);
}

void XPluginAsync::PushMsg(XProtoMessagePtr msg, int32_t msg_dst) {
  XPlugin::PushMsg(msg, msg_dst);
}

int XPluginAsync::TryPushMsg(XProtoMessagePtr msg, int32_t msg_dst) {
  return XPlugin::TryPushMsg(msg, msg_dst);
}

int XPluginAsync::DeInit() {
  std::lock_guard<std::mutex> lock(msg_map_mutex_);
  for (auto &msginfo : msg_map_) {
    XPlugin::UnRegisterMsg(msginfo.first);
  }
  msg_map_.clear();
  if (msg_handle_) {
    xproto::CThreadPool *msg_handle_ptr =
        static_cast<xproto::CThreadPool *>(msg_handle_);
    msg_handle_ptr->ClearTask();
    delete msg_handle_ptr;
  }
  return 0;
}

void XPluginAsync::OnMsg(XProtoMessagePtr msg) {
  xproto::CThreadPool *msg_handle_ptr =
      static_cast<xproto::CThreadPool *>(msg_handle_);
  // 实现消息队列和流量控制
  std::lock_guard<std::mutex> lock(msg_mutex_);
  if (msg_handle_ptr->GetTaskNum() >= 30) {
    LOGW << "Task Size: " << msg_handle_ptr->GetTaskNum();
  }
  msg_handle_ptr->PostTask(std::bind(&XPluginAsync::OnMsgDown, this, msg));
}

int XPluginAsync::GetPluginMsgCount() {
  xproto::CThreadPool *msg_handle_ptr =
      static_cast<xproto::CThreadPool *>(msg_handle_);
  std::lock_guard<std::mutex> lock(msg_mutex_);
  return msg_handle_ptr->GetTaskNum();
}

int XPluginAsync::GetPluginMsgLimit() {
  std::lock_guard<std::mutex> lock(msg_limit_mutex_);
  return msg_limit_count_;
}

void XPluginAsync::SetPluginMsgLimit(int msg_limit_count) {
  if (msg_limit_count <= 0) {
    return;
  }
  std::lock_guard<std::mutex> lock(msg_limit_mutex_);
  msg_limit_count_ = msg_limit_count;
}

int XPluginAsync::GetMsgMonitorTime() {
  std::lock_guard<std::mutex> lock(msg_monitor_mutex_);
  return msg_monitor_time_;
}

void XPluginAsync::SetMsgMonitorTime(int msg_monitor_time) {
  if (msg_monitor_time < 0) {
    return;
  }
  std::lock_guard<std::mutex> lock(msg_limit_mutex_);
  msg_monitor_time_ = msg_monitor_time;
}

void XPluginAsync::OnMsgDown(XProtoMessagePtr msg) {
  HOBOT_CHECK(msg_map_.count(msg->type()))
      << "No message type:" << msg->type() << " registered in " << desc();

  auto plugin_start = std::chrono::system_clock::now();
  msg_map_[msg->type()](msg);
  auto plugin_stop = std::chrono::system_clock::now();
  auto interval = std::chrono::duration_cast<std::chrono::milliseconds>(
                      plugin_stop - plugin_start)
                      .count();
  if (interval >= msg_monitor_time_) {
    LOGW << "Plugin: " << desc() << ", MsgType = " << msg->type()
         << ", cost time = " << interval << "(ms)";
  }
}

XPluginAsync::XPluginAsync() {
  xproto::CThreadPool *msg_handle_ptr = new xproto::CThreadPool();
  msg_handle_ptr->CreatThread(1);
  msg_handle_ = msg_handle_ptr;
  LOGI << "XPluginAsync() construct";
}
XPluginAsync::XPluginAsync(int thread_num) {
  xproto::CThreadPool *msg_handle_ptr = new xproto::CThreadPool();
  msg_handle_ptr->CreatThread(thread_num);
  msg_handle_ = msg_handle_ptr;
  LOGD << "set XPluginAsync thread num = " << thread_num;
}

}  // namespace xproto
