/*!
 * -------------------------------------------
 * Copyright (c) 2019, Horizon Robotics, Inc.
 * All rights reserved.
 * \File     xplugin.h
 * \Author   Yingmin Li
 * \Mail     yingmin.li@horizon.ai
 * \contributor  songshan.gong
 * \Mail     songshan.gong@horizon.ai
 * \Version  1.0.0.0
 * \Date     2019-07-29
 * \Brief    implement of xplugin.h
 * \DO NOT MODIFY THIS COMMENT, \
 * \WHICH IS AUTO GENERATED BY EDITOR
 * -------------------------------------------
 */

#ifndef XPROTO_INCLUDE_XPROTO_PLUGIN_XPLUGINASYNC_H_
#define XPROTO_INCLUDE_XPROTO_PLUGIN_XPLUGINASYNC_H_
#include <functional>
#include <map>
#include <mutex>
#include <string>

#include "xproto/version.h"
#include "xproto/message/flowmsg.h"
#include "xproto/plugin/xplugin.h"

namespace xproto {

/*
 * \Desc Plugin implementation
 * Message processing includes the upper part and the lower part:
 * 1) The upper part receives bus messages and pushes them to the local queue;
 * 2) The local execution engine schedules the lower part to complete the
 * distribution and processing of messages
 *
 * @brief Two basic classes XPlugin and XPluginAsync are implemented. To
 * implement a custom plugin, you only need to inherit any one of them. It is
 * recommended to choose the XPluginAsync class. There are some differences
 * between the two basic classes, which are explained as follows: XPluginAsync
 * is a subclass of XPlugin. XPluginAsync implements the asynchronous processing
 * mechanism of messages. XPlugin provides interfaces for message distribution,
 * get & set the upper limit of message number, get & set message processing
 * timeout time, etc. The subclasses implement the corresponding interface to
 * implement the plugin function. XPluginAsync inherits from XPlugin and
 * implements functions such as message distribution, flow control, and message
 * processing timeout monitoring. Subclasses only need to pay attention to the
 * plugin's own functions.
 */
class XPROTO_EXPORT XPluginAsync : public XPlugin {
 public:
  XPluginAsync();
  explicit XPluginAsync(int thread_num);
  ~XPluginAsync() = default;

  /**
   * @description: Register the monitoring message type to the initialization of
   * the bus and Initialize Plugin: This interface needs to be inherited from
   * the custom Plugin of the XPluginAsync class to implement the interface
   * definition. This interface is used to initialize the Plugin. Custom Plugin
   * generally calls the subscription message interface in this interface.
   * @param {*} None
   * @return {*} zero:success non-zero:failure
   */
  int Init() override;
  /**
   * @description: De-initialize Plugin: This interface needs to be inherited
   * from the custom Plugin of the XPluginAsync class to implement the interface
   * definition. This interface is used to de-initialize the Plugin. Inherited
   * from the XPluginAsync child plugin class. After completing your
   * deinitialization task, you finally need to call the XPluginAsync::DeInit
   * interface to deinitialize the parent class.
   * @param {*} None
   * @return {*} zero:success non-zero:failure
   */
  int DeInit() override;

  // The upper part of message processing, push the message to the message queue
  // of the plugin + flow control
  void OnMsg(XProtoMessagePtr msg) override;

  /**
   * @description: Start Plugin: This interface needs a custom Plugin inherited
   * from the XPluginAsync class to implement the interface definition. This
   * interface is used to start the Plugin.
   * @param {*} None
   * @return {*} zero:success non-zero:failure
   */
  virtual int Start() { return 0; }

  /**
   * @description: Stop Plugin: This interface needs a custom Plugin inherited
   * from the XPluginAsync class to implement the interface definition. This
   * interface is used to stop the Plugin.
   * @param {*} None
   * @return {*} zero:success non-zero:failure
   */
  virtual int Stop() { return 0; }

  /**
   * @description: Get the number of msgs to be processed in the plugin, which
   * is used to get the number of msgs to be processed in the plugin.
   * @param {*} None
   * @return {*} Returns the number of msg to be processed by the plugin
   */
  int GetPluginMsgCount();

  /**
   * @description: Get the maximum number of msgs processed by the plugin.
   * @param {*} None
   * @return {*} Returns the upper limit of the number of msgs processed by the
   * plugin
   */
  int GetPluginMsgLimit();

  /**
   * @description: Set the upper limit of the number of msgs processed by the
   * plugin.
   * @param {int} msg_limit_count[in]: Set the upper limit of the number of msgs
   * that the plugin can handle
   * @return {*} None
   */
  void SetPluginMsgLimit(int msg_limit_count);

  /**
   * @description: Get msg processing timeout time.
   * @param {*} None
   * @return {*} message processing timeout.
   */
  int GetMsgMonitorTime();

  /**
   * @description: Set msg processing timeout time.
   * @param {int} msg_monitor_time[in]: msg processing timeout.
   * @return {*} None
   */
  void SetMsgMonitorTime(int msg_monitor_time);

 protected:
  using XProtoMessageFunc = std::function<int(XProtoMessagePtr)>;

  /**
   * @description: Subscribe to the message: subscribe to the specified type of
   * message. Monitor the bus, and call the callback function when the specified
   * message type is published. Overload the registration and monitoring message
   * type interface, including asynchronous callback function when registering.
   * Note: The custom plugin needs to be in the Init function,
   * call this interface to complete the monitoring message registration before
   * calling XPluginAsync::Init.
   * @param {const std::string&} type[in]: message type string.
   *       {XProtoMessageFunc} callback[in]: The callback function of this type
   * of message.
   * @param {msg_source} 0: recv msg from self-process and network both, 1:recv
   * msg from self-process
   * @return {*} None
   */
  void RegisterMsg(const std::string& type, XProtoMessageFunc callback,
                   int32_t msg_source = 0);

  /**
   * @description: Cancel message subscription: cancel the subscription of the
   * specified type of message. After unsubscribing, the plugin will no longer
   * receive this type of message.
   * @param {const std::string&} type[in]: message type string.
   * @return {*} None
   */
  void UnRegisterMsg(const std::string& type);
  /**
   * @description: Publish messages: This interface is used to publish messages
   * to the XProto internal bus. If the message is congested, the message will
   * be published after waiting for the channel to clear. Receive a structure
   * pointer of type XProtoMessage, all XProto messages inherit from this type.
   * @param {XProtoMessagePtr} the message pushed to the xproto bus
   * @param {int32_t} 0: push msg to self-process and network both, 1: push msg
   * to self-process only.
   * @return {*} None
   */
  void PushMsg(XProtoMessagePtr msg, int32_t msg_dst = 0);

  /**
   * @description: Publish message: This interface attempts to publish the
   * message to the XProto internal bus. If the message is congested, the
   * message will be discarded and returned immediately. Receive a structure
   * pointer of type XProtoMessage, all XProto messages inherit from this type.
   * @param {XProtoMessagePtr} the message pushed to the xproto bus
   * @param {int32_t} 0: push msg to self-process and network both, 1: push msg
   * to self-process only.
   * @return {*} None
   */
  int TryPushMsg(XProtoMessagePtr msg, int32_t msg_dst = 0);

 private:
  // The lower part of message processing, distribute the message and call the
  // corresponding callback function
  void OnMsgDown(XProtoMessagePtr msg);

  void* msg_handle_ = nullptr;
  std::mutex msg_mutex_;
  int msg_limit_count_ = 0;
  std::mutex msg_limit_mutex_;
  // The processing of monitoring messages in plugin takes time, and alarm
  // messages are provided over time
  int msg_monitor_time_ = 0;
  std::mutex msg_monitor_mutex_;
  std::map<std::string, XProtoMessageFunc> msg_map_;
  std::mutex msg_map_mutex_;
};

}  // namespace xproto

#endif  // XPROTO_INCLUDE_XPROTO_PLUGIN_XPLUGINASYNC_H_
