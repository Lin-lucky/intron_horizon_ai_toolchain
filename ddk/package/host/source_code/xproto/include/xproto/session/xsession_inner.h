/*!
 * -------------------------------------------
 * Copyright (c) 2019, Horizon Robotics, Inc.
 * All rights reserved.
 * \File     xsession.h
 * \Author   Xudong Du
 * \Mail     Xudong.du@horizon.ai
 * \Version  1.0.0.0
 * \Date     2019-04-22
 * \Brief    implement of msg_manager.h
 * \DO NOT MODIFY THIS COMMENT, \
 * \WHICH IS AUTO GENERATED BY EDITOR
 * -------------------------------------------
 */

#ifndef XPROTO_INCLUDE_XPROTO_SESSION_XSESSION_INNER_H_
#define XPROTO_INCLUDE_XPROTO_SESSION_XSESSION_INNER_H_
#include <algorithm>
#include <iostream>
#include <map>
#include <memory>
#include <mutex>
#include <string>
#include <vector>

#include "xproto/message/flowmsg.h"
#include "xproto/session/xsession_info.h"
#include "xproto/session/xsocket.h"
#include "xproto/threadpool.h"
#include "xproto/utils/singleton.h"

namespace xproto {

class XSessionInner : public MessageCallBack,
                      public xproto::CSingleton<XSessionInner> {
 public:
  XSessionInner();
  ~XSessionInner() {}
  /**
   * @description: Set as master device and set session to master mode. If the
   * messages generated by this plugin need to flow to the plugin on another
   * device, you can set the device to master mode.
   * @param {int32_t} listenting port
   * @return {*} zero:success non-zero:failure
   */
  int32_t AsMaster(const std::string &host_ip, uint16_t host_port);
  /**
   * @description: Connect to master device and set session to slave mode. If
   * you want to subscribe to Plugin messages on other devices, you need to
   * connect to other devices first, and then subscribe to the corresponding
   * messages. If connected to master device, Specified messages can flow
   * between devices.
   * @param {std::string} master device IP
   * @param {int32_t} listenting port
   * @return {*} zero:success non-zero:failure
   */
  int32_t ConnectTo(const std::string &ip, uint16_t port);
  /**
   * @description: Query Session messages
   * @param None
   * @return {*} return Info of plugin session info.
   */
  std::vector<SessionInfo> Info();
  /**
   * @description: reset Session to default Local Mode
   * @param None
   * @return None
   */
  void Reset();
  /**
   * @description: Dispatch msg
   * @param msg
   * @return None
   */
  void Dispatch(XProtoMessagePtr msg);
  /**
   * @description: RegisterMsg Session
   * @param std::string& msg type
   * @return None
   */
  void RegisterMsg(const std::string& msg_type);
  /**
   * @description: UnRegisterMsg Session
   * @param std::string& msg type
   * @return None
   */
  void UnRegisterMsg(const std::string& msg_type);
  /**
   * @description: Close Session
   * @param None
   * @return None
   */
  void Close();
  virtual int OnMessage(ActionType action_type, std::string& msg_type,
                         std::string& data);

 private:
  void RecvThread();
  void SendMsgProc(XProtoMessagePtr msg);

 private:
  bool is_inited_ = false;
  std::shared_ptr<XSocket> socket_;
  SessionInfo session_info_;
  xproto::CThreadPool recv_handle_;
  xproto::CThreadPool send_handle_;
  std::atomic<bool> stop_;
  /**
   * @description: subscribe msg
   * @param std::string msg type
   * @param uint64_t msg subscribe time
   * @return None
   */
  std::map<std::string, uint64_t> sub_msg_types_;
  std::mutex sub_msg_types_mtx_;
  std::string session_version_ = "session.1.0.1";
};
}  // namespace xproto

#endif  // XPROTO_INCLUDE_XPROTO_SESSION_XSESSION_INNER_H_
