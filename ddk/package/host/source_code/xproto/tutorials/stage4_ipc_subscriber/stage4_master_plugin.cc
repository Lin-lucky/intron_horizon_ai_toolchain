/*!
 * -------------------------------------------
 * Copyright (c) 2019, Horizon Robotics, Inc.
 * All rights reserved.
 * \File     stage4_Master_plugin.cpp
 * \Author xudong.du
 * \Mail     xudong.du@horizon.ai
 * \Version  1.0.0.0
 * \Date     2019-07-30
 * \Brief    Sample custom plugin
 * \DO NOT MODIFY THIS COMMENT, \
 * \WHICH IS AUTO GENERATED BY EDITOR
 * -------------------------------------------
 */

#include <signal.h>
#include <unistd.h>

#include <chrono>
#include <iostream>
#include <sstream>
#include <thread>

#include "hobotlog/hobotlog.hpp"
#include "xproto/msg_type/control_message.h"
#include "xproto/msg_type/smart_legible_message.h"
#include "xproto/session/xsession.h"
#include "xproto/xproto_world.h"

/*
 * 框架包含三部分：总线、消息、插件。
 * 总线是系统框架，用户不用care;
 * 插件的定义：
 * 1.需要继承XPluginAsync，通常需要override的函数包括:
 *   Init()、Start()、Stop()、Desc();
 * 2.插件可能会生产消息或者向总线注册监听某类消息：
 *   如果生产消息需要调用PushMsg()将消息发送到总线分发;
 *   如果监听消息，需要实现消息处理函数，并在Init函数中
 *   注册需要监听的消息类型，并绑定对应的消息处理函数，
 *   同时在Init函数返回前调用父plugin的Init方法，
 *   通常是XPluginAsync::Init()。
 * 消息的声明与定义：
 * 1.使用宏XPLUGIN_REGISTER_MSG_TYPE,自定义消息类型，每个消息名字唯一；
 * 2.定义新的Message需要继承XProtoMessage;
 * 3.需要监听消息的插件需要：
 *   a.实现消息处理函数；
 *   b.覆盖Init函数，在其中完成监听消息注册，并绑定对应的消息处理函数，
 *     及其他初始化工作，同时在函数返回前需要调用父plugin的Init方法，
 *     通常是XPluginAsync::Init()。
 */

using xproto::XPluginAsync;
using xproto::XProtoMessage;
using xproto::XProtoMessagePtr;

using std::chrono::milliseconds;
using std::chrono::seconds;
using xproto::message::ControlMessage;
using xproto::message::ControlMessagePtr;
using xproto::message::SmartLegibleMessage;
using xproto::message::SmartLegibleMessagePtr;

XPLUGIN_REGISTER_MSG_TYPE(XPLUGIN_SMART_LEGIBLE_MESSAGE);
XPLUGIN_REGISTER_MSG_TYPE(XPLUGIN_CONTROL_MESSAGE);

class ExampleMasterPlugin : public xproto::XPluginAsync {
 public:
  explicit ExampleMasterPlugin(std::string config_path) {
    LOGD << "ExampleMasterPlugin config_path = " << config_path;
  }
  ~ExampleMasterPlugin() {}
  int Init() override {
    LOGI << "ExampleMasterPlugin Init.";
    RegisterMsg(TYPE_CONTROL_MESSAGE,
                std::bind(&ExampleMasterPlugin::FeedControl, this,
                          std::placeholders::_1));
    return 0;
  }
  int DeInit() override {
    LOGD << "ExampleMasterPlugin::DeInit.";
    return 0;
  }
  int Start() override {
    LOGD << "ExampleMasterPlugin::Start.";
    int time = 20 * 1000;
    while (time > 0) {
      CreateSmartLegibleMessage();
      std::this_thread::sleep_for(milliseconds(30));
      time -= 33;
    }
    LOGD << "ExampleMasterPlugin::start exit.";
    return 0;
  }
  int Stop() override {
    LOGD << "ExampleMasterPlugin::Stop.";
    return 0;
  }

  std::string desc() const { return "ExampleMasterPlugin"; }

 private:
  int FeedControl(XProtoMessagePtr msg) {
    if (nullptr == msg) {
      return -1;
    }
    auto control_data = std::static_pointer_cast<ControlMessage>(msg);
    LOGD << "******ExampleMasterPlugin::FeedControl******";
    LOGD << "control timestamp = " << control_data->time_stamp_;
    LOGD << "control cmd_id = " << control_data->message_.cmd_id_;
    LOGD << "control type = " << control_data->message_.type_;
    LOGD << "control value = " << control_data->message_.value_;
    LOGD << "******ExampleMasterPlugin::FeedControl End ******";
    return 0;
  }
  int CreateSmartLegibleMessage() {
    LOGD << "******ExampleMasterPlugin::CreateSmartLegibleMessage******";
    auto smart_data = std::make_shared<SmartLegibleMessage>();

    auto cur_time = std::chrono::system_clock::now();
    smart_data->time_stamp_ = cur_time.time_since_epoch().count();
    smart_data->frame_id_ = frame_id_++;
    LOGD << "Create SmartLegibleMessage: time_stamp = "
         << smart_data->time_stamp_ << ", frame_id = " << smart_data->frame_id_;
    for (int index = 1; index <= 2; index++) {
      auto dst_target = std::make_shared<xproto::message::Target>();

      smart_data->smart_data_.error_code_ = 0;
      smart_data->smart_data_.targets_.push_back(dst_target);

      dst_target->type_ = "test_person";
      dst_target->track_id_ = index;
      for (int box_index = 1; box_index < 3; box_index++) {
        auto dst_box = std::make_shared<xstream::BBox>();
        dst_box->name_ = "test_box";
        dst_box->score_ = 0.999;
        dst_box->x1_ = 1.0 + box_index * 6;
        dst_box->y1_ = 100.0 + box_index * 6;
        dst_box->x2_ = 1.0 + box_index * 6;
        dst_box->y2_ = 100.0 + box_index * 6;

        dst_target->boxs_.push_back(dst_box);
      }
    }
    PushMsg(smart_data);
    LOGD << "******ExampleMasterPlugin::CreateSmartLegibleMessage end******";
    return 0;
  }
  int frame_id_ = 0;
};

int main(int argc, char **argv) {
  if (argc < 2) {
    std::cout
        << "Usage: stage4_ipc_subscriber_master port"
        << std::endl;
    return 0;
  }
  SetLogLevel(HOBOT_LOG_DEBUG);
  uint16_t port = atoi(argv[1]);

  std::cout << "prot = " << port << std::endl;

  xproto::XSession::Instance().AsMaster(port);

  std::string example_config = "example.json";

  auto example_plg = std::make_shared<ExampleMasterPlugin>(example_config);

  example_plg->Init();

  example_plg->Start();

  // std::this_thread::sleep_for(seconds(20));

  example_plg->Stop();

  example_plg->DeInit();
  xproto::XSession::Instance().Reset();

  return 0;
}
